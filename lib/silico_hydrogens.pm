#!/usr/bin/perl -w

#  COPYRIGHT NOTICE
#  
#  Silico - A Perl Molecular Toolkit
#  Copyright (C) 2008-25 David K. Chalmers and Benjamin P. Roberts,
#  Department of Medicinal Chemistry, Monash University
#  
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.


#<
#! silico_hydrogens.pm
#? Routines to add and delete hydrogen atoms
#. $Revision: 1.46.2.7.2.9 $
#>

use strict;
package Silico;

sub mol_add_h {

	die ("The subroutine is actually called 'mol_add_hydrogens'\n");
}

sub mol_add_hydrogens {

	#<
	#? Add hydrogens to a molecule
	#. By default the routine tries to approximate the protonation state
	#  at physiological pH. The charge state is generated by mol_type_sybyl
	#. Carboxylic acids are deprotonated.
	#. Non-aromatic amines are protonated.
	#. Aromatic and heterocylic amines are not protonated
	#.
	#  This can be turned of using the fill_valence flag.
	#. The Sybyl atom typing routines are used to generate atom types
	#; Requires: Molecule, flag to add all hydrogens (routine otherwise
	#  approximates protonation state at physiological pH), flag to add polar (1) or nonpolar (carbon) hydrogens (2), 
	#  flag to delete hydrogens only from atoms where hydrogens need to be added.
	#  Otherwise all hydrogens are deleted first and then appropriate hydrogens are added back.
	#; Returns: Number of hydrogens added, number of hydrogens deleted, total change
	#>

	my $mol = $_[0];
	my $fill_valence = $_[1] || 0;
	my $polar = $_[2] || 0; # Only add polar hydrogens
	my $nodel = $_[3] || 0; # Only delete hydrogens from atoms where hydrogens need to be added

	return mol_add_hydrogens_nocoords($mol,$polar) if $mol->{HAS_NO_COORDS};

	standard_bond_lengths();

	my $change;
	my $mol_addcount = 0;
	my $mol_delcount = 0;
	my @list;

	if (!$fill_valence) {
	
		# Calculate an approximate protonation state
		calc_physiological_protonation($mol);
	}
	
	# Delete hydrogens from any atom that needs to have the total number of hydrogens altered
	ATOM: foreach my $atom (atoms($mol)) {
	
		# Atoms may be undefined if we have deleted them and not yet run molecule_pack
		next if !defined $atom;
		
		# Skip carbon atoms if we have asked for polar hydrogens only
		next if $polar == 1 && $atom->{ELEMENT} eq 'C';
		next if $polar == 2 && $atom->{ELEMENT} ne 'C';
		
		# Go to next atom if no change the number of hydrogens
		$change = calc_valence_change($atom);
		next if $change == 0;
		next if $nodel && $change < 0;
		
		# Delete all hydrogens
		my $atom_delcount = 0;
		foreach my $connum (@{$atom->{CONNECT}}) {

			my $con = $mol->{ATOMS}[$connum];
		
			next if !defined $con;
			next if $con->{ELEMENT} ne 'H';

			# Delete hydrogen
			molecule_delete_atom($mol, $connum);
				
			++$atom_delcount;
		}
		
		$mol_delcount += $atom_delcount;
		
		push @list, $atom;
	}
	
	# Clean up gaps left by deleting atoms
	molecule_pack($mol);
	
	# Add back hydrogens
	foreach my $atom (@list) {
		
		# Skip carbon atoms if we have asked for polar hydrogens only
		#next if $polar == 1 && $atom->{ELEMENT} eq 'C';
		#next if $polar == 2 && $atom->{ELEMENT} ne 'C';
		
		my $element = $atom->{ELEMENT};
		my $atom_addcount = calc_valence_change($atom);
		
		next if ($atom_addcount <= 0);
		
		my $s = "H-$element";
		my $bl = $Silico::Bond_Lengths{$s};
		
		if (!defined $bl) {
			silico_msg('w', "Can't add hydrogens to element $element.\n");
			next;
		}
		
		atom_add_h($atom, $mol, $bl, $atom_addcount);

		$mol_addcount += $atom_addcount;
	}
	
	#molecule_formal_charge($mol, undef, undef, get_lflag("print-formal"));

	return ($mol_addcount, $mol_delcount, $mol_addcount - $mol_delcount);
}

sub mol_add_hydrogens_nocoords {

	#<
	#? Add hydrogens to a molecule that lacks coordinates (e.g. SMILES)
	#; Returns: Number of hydrogens added, number of hydrogens deleted (always zero), total change
	#>

	my $mol = $_[0];
	my $polar = $_[1];

	mol_calc_hcount($mol);
	standard_bond_lengths();
	
	my $mol_addcount = 0;

	foreach my $atom (atoms($mol)) {

		my ($x, $y, $z);
		# Even though the molecule may lack coordinates, it may have defined, bogus coords
		if (defined $atom->{X} && defined $atom->{Y} && defined $atom->{Z}) {

			my $s = "H-$atom->{ELEMENT}";
			my $bl = $Silico::Bond_Lengths{$s};
			atom_add_h($atom, $mol, $bl, $atom->{HMISSING}) if $atom->{HMISSING};
			++$mol_addcount;
			$atom->{HMISSING} = 0;

		} else {

			my $hcount = 0;
			foreach (1..$atom->{HMISSING}) {
				mol_add_atom($mol, 'H', 'H', $x, $y, $z, $atom->{SUBNAME}, $atom->{SUBID});
				++$mol_addcount;
			}
			$atom->{HMISSING} = 0;
		}
	}
	
	return ($mol_addcount, 0, $mol_addcount);
}

sub mol_calc_hcount {

	#<
	#? Calculate number of hydrogens on each heavy atom (but don't add them).
	#; Requires: Molecules, atomlist, fill_valence flag (default on)
	#; Sets: atom->{HCOUNT}, $atom->{HMISSING}
	#; Returns: Nothing
	#>

	my $mol = $_[0];
	my $list = $_[1];
	my $fill_valence = $_[2] || 1;
	
	molecule_check_and_fix_connectivity($mol) if !$mol->{CONNECTIVITY_CHECKED};
	
	@$list = atoms($mol) if !$list;
	
	if (!$fill_valence) {
	
		# Calculate an approximate protonation state
		calc_physiological_protonation($mol);
	}
	
	foreach my $atom (@$list) {
	
		next if $atom->{ELEMENT} eq 'H';
	
		my $hcount = 0;
		foreach my $con (connected($atom, $mol)) {
		
			next if $atom->{ELEMENT} ne 'H';
			++$hcount;
		}
		
		my $val = calc_valence_change($atom);
		
		$atom->{HCOUNT} = $hcount+$val;
		$atom->{HMISSING} = $val;
		
		#print "$atom->{NAME} $atom->{NUM} hcount $hcount vchange $val\n" if $val != 0;
	}
}

sub mol_add_lone_pairs {

	#<
	#? Add lone pairs to N, O or S atoms in a molecule
	#; Requires: Molecule
	#; Returns: Number of lone pairs
	#>

	my $mol = $_[0];

	my $store = $Silico::add_h_element;
	$Silico::add_h_element = 'Lp';
	
	my $total = 0;
	
	molecule_find_rings ($mol);
	molecule_find_planar_atoms($mol) if (!defined $mol->{PLANAR_ATOMS});
	
	foreach my $atom (atoms($mol)) {
	
		my $num = 0;
		my $el = $atom->{ELEMENT};
		my $valence = valence($atom, $mol);
		my $planar5 = 0;
		my $con_planar = 0;
		
		foreach my $ring (@{$atom->{PRINGS}}) {
			$planar5 = 1 if $#{$ring} == 4;
		}
		
		foreach my $con (connected($atom, $mol)) {
			$con_planar = 1 if $con->{PLANAR_ATOM};
		}
		
		if ($el eq 'N') {
			$num = 4 - $valence;
			$num -= 1 if $con_planar && !$atom->{PRINGS}[0];
		}
		if ($el eq 'O') {
			$num = 4 - $valence;
		}
		if ($el eq 'S') {
			$num = 4 - $valence;
		}
		
		$num -=1 if $planar5;
		$num = 0 if $num < 0;
		
		next if !$num;
		
		$total += $num;
		
		# Uses atom_add_h but changes
		# to lone pairs using global variable
		atom_add_h($atom, $mol, 1, $num);
	}
	
	$Silico::add_h_element = $store;
	
	return $total;
}

sub mol_del_hydrogens {

	my $mol = $_[0];
	
	my $delcount = 0;
	
	my $i = -1;
	foreach my $atom (atoms($mol)) {
	
		++$i;

		next if $atom->{ELEMENT} ne 'H';

		# Delete hydrogen
		molecule_delete_atom($mol, $i);
				
		++$delcount;
	}
	
	molecule_pack($mol);
	
	return $delcount;
}

	
sub calc_valence_change {

	#<
	#? Calculate the difference between expected and actual valence
	#. Takes $atom->{CONNECTED_NON_H} flag into consideration
	#. Note treatment of P valence is simplistic
	#; Requires: atom
	#; Returns: difference between expected and actual
	#>

	my $atom = $_[0];
	
	my %std_valence = qw(H 1 B 3 C 4 N 3 O 2 S 2 P 5);
	my $element = $atom->{ELEMENT};
	
	return 0 if !defined $std_valence{$element};
	
	my $valence = valence($atom);
	my $fc = $atom->{FORMAL_CHARGE} || 0;
	#print "val $valence fc $fc\n";
	
	my $change = $std_valence{$element} + $fc - $valence - ($atom->{CONNECTED_NON_H} || 0);

	return $change;
}

sub atom_add_h {

	#<
	#? Add specified number of hydrogens to an atom
	#; Requires: atom, molecule, bondlength, number of hydrogens to add (in addition to any existing atoms)
	#>

	my $atom = $_[0];
	my $mol = $_[1];
	my $bondlength = $_[2];
	my $num = $_[3] || croak();

	atom_add_1h($atom, $mol, $bondlength) if $num == 1;
	atom_add_2h($atom, $mol, $bondlength) if $num == 2;
	atom_add_3h($atom, $mol, $bondlength) if $num == 3;
	if ($num == 4) {
		atom_add_1h($atom, $mol, $bondlength);
		atom_add_3h($atom, $mol, $bondlength);
	}
}

sub atom_add_1h {

	#<
	#? Add one hydrogen to an atom
	#. This code needs a good clean up!
	#. This code can add hydrogens with a steric clash.  e.g biguanides
	#>

	my $atom = $_[0];
	my $mol = $_[1];
	my $bondlength = $_[2];
	
	# If atom only has one or zero bonds
	if ($#{$atom->{CONNECT}} <= 0) {

		my ($vx, $vy, $vz);
		if ($#{$atom->{CONNECT}} == 0) {

			my $con = $mol->{ATOMS}[$atom->{CONNECT}[0]];
			($vx, $vy, $vz) = atom_norm_vector($atom, $con);

		} else  {

			$vx = 1; $vy = 0; $vz = 0;
		}
		
		# Make a vector at right angles to bond
		# but make sure that cx and cy are not zero
		my ($cx, $cy, $cz);
		if (abs $vx > 0.01 || abs $vy > 0.01) {
			my $d = sqrt($vx**2+$vy**2);
			$cx = $vy/$d;
			$cy = -$vx/$d;
			$cz = 0;
		} else {

			$cx = 0;
			$cy = 1;
			$cz = 0;
		}
	
		# Calculate adding the hydrogen in two directions
		my $nx1 = (0.326*$vx + 0.946*$cx)*$bondlength;
		my $ny1 = (0.326*$vy + 0.946*$cy)*$bondlength;
		my $nz1 = (0.326*$vz + 0.946*$cz)*$bondlength;
		
		my $nx2 = (0.326*$vx - 0.946*$cx)*$bondlength;
		my $ny2 = (0.326*$vy - 0.946*$cy)*$bondlength;
		my $nz2 = (0.326*$vz - 0.946*$cz)*$bondlength;
	
		# Find if either of the directions clash
		if (findclash ($mol, $atom, $nx1, $ny1, $nz1) < findclash ($mol, $atom,  $nx2, $ny2, $nz2)) {
			new_h($atom, $mol, $nx1, $ny1, $nz1);
		} else {
			new_h($atom, $mol, $nx2, $ny2, $nz2);
		}
		return;
	}
	
	my $count = 0;
	my $avx = 0;
	my $avy = 0;
	my $avz = 0;
	foreach my $connum (@{$atom->{CONNECT}}) {
	
		my $con = $mol->{ATOMS}[$connum];
		
		my @vec = atom_norm_vector($con, $atom);
		
		$avx += $vec[0];
		$avy += $vec[1];
		$avz += $vec[2];
		
		++$count;
	}
	
	if ($count == 0) {
		$avx = $atom->{X} + 1;
		$avy = 0;
		$avy = 0;
	} else {
	
		# Average position of connected atoms
		$avx = $avx/$count;
		$avy = $avy/$count;
		$avz = $avz/$count;
	}
	
	my $d = sqrt($avx**2+$avy**2+$avz**2);
	
	# Something strange is going on if this distance is small
	# (molecule may be flat).  If this is so add hydrogen at
	# right angles to plane of connected atoms

	#silico_msg('g', "(".subname().") ");

	if ($d < 0.2) {
	
		#silico_msg('g', "Flat molecule. ");
		my $con1 = $mol->{ATOMS}[$atom->{CONNECT}[0]];
		my $con2 = $mol->{ATOMS}[$atom->{CONNECT}[1]];

		($avx, $avy, $avz) = atom_cross_prod($con1, $atom, $con2);
		$d = 1;
	}

	# Vector of new atom
	my $vx = -$avx / $d * $bondlength;
	my $vy = -$avy / $d * $bondlength;
	my $vz = -$avz / $d * $bondlength;

	new_h($atom, $mol, $vx, $vy, $vz);
}

sub atom_add_2h {

	#<
	#? Add two hydrogens to an atom
	#. If atom has only one connected atom hydrogens are added in the plane
	#  generated from the connected atom
	#
	#>

	my $atom = $_[0];
	my $mol = $_[1];
	my $bondlength = $_[2];
	
	my ($avx, $avy, $avz);
	my ($cx, $cy, $cz);
	my ($nx, $ny, $nz);
	my ($vx, $vy, $vz);
	
	# Number of connected atoms
	my $concount = $#{$atom->{CONNECT}} + 1;
	
	if ($concount == 0) {
		
		# If no connected atoms just make a vector along X axis
		$vx = 1;
		$vy = 0;
		$vz = 0;

	} else {
		
		$avx = 0;
		$avy = 0;
		$avz = 0;
	
		# One or more connected atoms
		# Average position of connected atoms
		foreach my $connum (@{$atom->{CONNECT}}) {
	
			my $con = $mol->{ATOMS}[$connum];
		
			$avx += $con->{X};
			$avy += $con->{Y};
			$avz += $con->{Z};
		}
		
		$avx = $avx/$concount;
		$avy = $avy/$concount;
		$avz = $avz/$concount;

		my $d = sqrt(($atom->{X}-$avx)**2+($atom->{Y}-$avy)**2+($atom->{Z}-$avz)**2);
		
		if ($d < 0.1) {
		
			# Atom has exceedingly poor geometry
			$d = 1;
		}

		# Unit vector pointing away from connected atoms (vx, vy, vz)
		$vx = ($atom->{X}-$avx)/$d;
		$vy = ($atom->{Y}-$avy)/$d;
		$vz = ($atom->{Z}-$avz)/$d;
	}
	
	# Calculate vector normal to (vx, vy, vz)
	if ($concount >= 2){

		# Two or more connected atoms
		# Calculate unit vector at right angles to connected atoms
		my $con1 = $mol->{ATOMS}[$atom->{CONNECT}[0]];
		my $con2 = $mol->{ATOMS}[$atom->{CONNECT}[1]];
		
		($cx, $cy, $cz) = atom_cross_prod($con1, $atom, $con2);
		
	} elsif ($concount == 1) {
	
		($cx, $cy, $cz) = make_vectors_connected($atom, $mol);

	} else {
	
		# No connected atoms
		$cx = 0;
		$cy = 1;
		$cz = 0;
	}

	#silico_msg('g', "(".subname().") Adding two hydrogens to $atom->{NAME}\n");

	# Atom 1
	$nx = (0.581*$vx+0.814*$cx)*$bondlength;
	$ny = (0.581*$vy+0.814*$cy)*$bondlength;
	$nz = (0.581*$vz+0.814*$cz)*$bondlength;

	new_h($atom, $mol, $nx, $ny, $nz);

	# Atom 2
	$nx = (0.581*$vx+0.814*-$cx)*$bondlength;
	$ny = (0.581*$vy+0.814*-$cy)*$bondlength;
	$nz = (0.581*$vz+0.814*-$cz)*$bondlength;

	new_h($atom, $mol, $nx, $ny, $nz);
}

sub atom_add_3h {

	#<
	#? Add three hydrogens to an atom
	#>

	my $atom = $_[0];
	my $mol = $_[1];
	my $bondlength = $_[2];
	
	my ($nx, $ny, $nz);
	my ($vx, $vy, $vz);
	
	#silico_msg('g', "(".subname().") Adding three hydrogens to $atom->{NAME}\n");
	
	my $connum = $atom->{CONNECT}[0];
	
	if (defined $connum) {
		my $con = $mol->{ATOMS}[$connum];
		($vx, $vy, $vz) = atom_norm_vector($atom, $con);
	} else {
		$vx = 1;
		$vy = 0;
		$vz = 0;
	}
	
	# Make a vector at right angles to bond
	my ($cx, $cy, $cz, $dx, $dy, $dz) = make_vectors_connected($atom, $mol);
	
	$nx = (0.326*$vx + 0.946*$cx)*$bondlength;
	$ny = (0.326*$vy + 0.946*$cy)*$bondlength;
	$nz = (0.326*$vz + 0.946*$cz)*$bondlength;
	
	new_h($atom, $mol, $nx, $ny, $nz);
	
	$nx = (0.326*$vx - 0.473*$cx + 0.819*$dx)*$bondlength;
	$ny = (0.326*$vy - 0.473*$cy + 0.819*$dy)*$bondlength;
	$nz = (0.326*$vz - 0.473*$cz + 0.819*$dz)*$bondlength;
	
	new_h($atom, $mol, $nx, $ny, $nz);
	
	$nx = (0.326*$vx - 0.473*$cx - 0.819*$dx)*$bondlength;
	$ny = (0.326*$vy - 0.473*$cy - 0.819*$dy)*$bondlength;
	$nz = (0.326*$vz - 0.473*$cz - 0.819*$dz)*$bondlength;
	
	new_h($atom, $mol, $nx, $ny, $nz);
}

sub new_h {
	
	#<
	#? Add a new hydrogens
	#. Note: The global Silco::add_h_element can be used to change the element being added
	#. Note: The global Silco::add_h_bo can be used to change the order of the new bond
	#; Requires: atom, molecule, offsetX, offsetY, offsetZ
	#; Returns: new atom
	#>
	
	#use vars qw($add_h_element);

	my $atom = $_[0];
	my $mol = $_[1];
	my $nx = $_[2];
	my $ny = $_[3];
	my $nz = $_[4];

	my $element = 'H';
	my $newatom;
	
	$element = $Silico::add_h_element if $Silico::add_h_element;

	$newatom = mol_add_atom($mol, $element, $element, $atom->{X}+$nx, $atom->{Y}+$ny, $atom->{Z}+$nz, $atom->{SUBNAME}, $atom->{SUBID});
	$newatom->{CHAIN} = $atom->{CHAIN};
	$newatom->{SEGID} = $atom->{SEGID};
	$newatom->{EXT} = $atom->{EXT};
	$newatom->{LABEL} = $atom->{LABEL};
	
	my $bo = 1;
	$bo = $Silico::add_h_bo if $Silico::add_h_bo;

	bond_create_atom($mol, $atom, $newatom, $bo);

	return $newatom;
}

sub atom_cross_prod {

	#<
	#? Calculate the normalised cross product of vectors defined by $atom0 ->atom1
	#  and atom0 -> atom2;
	#  Warning: this contains a horrible fudge if two atoms overlap
	#  or all three atoms are in a straight line
	#; Requires: atom0, atom1, atom2
	#; Returns: vector x, y, z
	#
	#       A1 ---- A0
	#               |
	#               |
	#               A2
	#>

	my $a0 = $_[0];
	my $a1 = $_[1];
	my $a2 = $_[2];

	my $x1 = $a1->{X} - $a0->{X};
	my $y1 = $a1->{Y} - $a0->{Y};
	my $z1 = $a1->{Z} - $a0->{Z};
	my $x2 = $a2->{X} - $a0->{X};
	my $y2 = $a2->{Y} - $a0->{Y};
	my $z2 = $a2->{Z} - $a0->{Z};

	# Calc cross product

	my @cp = crossprod($x1, $y1, $z1, $x2, $y2, $z2);

	my $l = sqrt($cp[0]**2 + $cp[1]**2 + $cp[2]**2);

	# Fudge it if atoms are in a straight line or overlapped
	# by moving two of the atoms just a little bit
	if ($l == 0) {

		# Bad connection table
		if ($a0 == $a2 || $a1 == $a2 || $a2 == $a0) {
			silico_msg('w', "Bad connection table. Fudging cross product\n");
			return (1, 0, 0);
		}

		# Horrible movement fudge
		my $r1 = rand(0.2)-0.1;
		my $r2 = rand(0.2)-0.1;
		my $r3 = rand(0.2)-0.1;
		my $r4 = rand(0.2)-0.1;

		$a1->{X} += $r1;
		$a2->{X} += $r1;
		$a2->{Y} += $r2;
		$a2->{Z} += $r2;
	
		my ($tempx, $tempy, $tempz);
		
		($tempx, $tempy, $tempz) = atom_cross_prod($a0, $a1, $a2);
		
		# Return things to the way they were
		$a1->{X} -= $r1;
		$a2->{X} -= $r1;
		$a2->{Y} -= $r2;
		$a2->{Z} -= $r2;
		
		return ($tempx, $tempy, $tempz);
	}

	my $xc = $cp[0]/$l;
	my $yc = $cp[1]/$l;
	my $zc = $cp[2]/$l;

	return ($xc, $yc, $zc);
}

sub atom_norm_vector {

	#<
	#? Return a unit vector atom1 -> atom2 for two atoms
	#>
	
	my $atom1 = $_[0];
	my $atom2 = $_[1];
	
	my $d = sqrt(($atom1->{X}-$atom2->{X})**2+($atom1->{Y}-$atom2->{Y})**2+($atom1->{Z}-$atom2->{Z})**2);
	
	if ($d == 0) {
		silico_msg('w', "Atoms $atom1->{NUM} and $atom2->{NUM} are in the same place!\n",
				"A unit vector between them can therefore not be calculated.\n",
				"Returning [1,0,0].\n");
		return (1,0,0);
	}

	return (($atom1->{X}-$atom2->{X})/$d, ($atom1->{Y}-$atom2->{Y})/$d,($atom1->{Z}-$atom2->{Z})/$d)
}

sub fix_hydrogens {

	#<
	#? Clean up hydrogens added to molecules by sybyl
	#. Removes hydrogens attached to nitro groups,
	#  on oxygen bonded to sulfur or phosphorous.
	#  Also removes comments
	#; Requires: molecule
	#>

	my $mols = $_[0];
	
	my $hcount;
	
	foreach my $mol (@$mols) {
	
		$mol->{COMMENTS} = '';
		my $del = 0;
	
		foreach my $atom (atoms($mol)) {
		
			next if !defined $atom; # Skip atoms we have already deleted (ugly but true)
		
			my @olist;
			my $ocount = 0;
		
			if ($atom->{ELEMENT} eq 'N') {
			
				# Find attached oxygens
				foreach my $connum (@{$atom->{CONNECT}}) {
			
					my $con = $mol->{ATOMS}[$connum];
				
					++$ocount if $con->{ELEMENT} eq 'O';
					push (@olist, $con) if $con->{ELEMENT} eq 'O';
				}
			
				# Skip if we don't have two attached oxygens
				next if $ocount < 2;
			
				silico_msg('n', "Found nitro group in molecule \"$mol->{NAME}\".\n");
				
				foreach my $o (@olist) {
			
					foreach my $connum (@{$o->{CONNECT}}) {
			
						my $con = $mol->{ATOMS}[$connum];
						if ($con->{ELEMENT} eq 'H') {
							silico_msg('c', "Deleting nitro hydrogen $con->{NUM} (name \"$con->{NAME}\", residue \"$con->{SUBNAME} $con->{SUBID})\"\n");
							molecule_delete_atom($mol, $connum);
							$del = 1;
						}
					}
				}
				
				#molecule_renumber($mol);
				next;
			}
			
			if ($atom->{ELEMENT} eq 'O') {
				# Find attached S or P
				my $flag = 0;
				foreach my $connum (@{$atom->{CONNECT}}) {
				
					my $con = $mol->{ATOMS}[$connum];
					
					++$flag if $con->{ELEMENT} eq 'S';
					++$flag if $con->{ELEMENT} eq 'P'
				}
				
				next if !$flag;
					
				foreach my $connum (@{$atom->{CONNECT}}) {
				
					my $con = $mol->{ATOMS}[$connum];
					
					next if $con->{ELEMENT} ne 'H';
					
					silico_msg('c', "Deleting [SP]O hydrogen $con->{NUM} (name \"$con->{NAME}\", residue \"$con->{SUBNAME} $con->{SUBID})\"\n");
					molecule_delete_atom($mol, $connum) if $con->{ELEMENT} eq 'H';
					$del = 1;
				}
				
				next;
			}
		}
		
		if ($del) {
			$mol = molecule_pack($mol);
			#molecule_renumber($mol);
		}
		
	}
}

sub mol_has_h {

	#<
	#? Find out if a molecule has no, polar or all hydrogens
	#. This check is quick and not exhaustive.  Note that it is fooled by
	#  molecules that contain a some hydrogens but not all valences are full
	#; Requires: molecule, flag to check if ANY hydrogens are present in file
	#; Returns: 0 if no hydrogens, 1 if polar hydrogens, 2 nonpolar hydrogens
	#  (ie connected to carbon) or -1 if hydrogens are present but bonds are not.
	#  Also sets $mol->{HAS_HYDROGENS}
	#>

	my $mol = $_[0];
	my $read_all = $_[1];
	
	my $c = 0;
	my $h_con_c = 0;
	my $h_con_p= 0;
	my $i = 0;
	my $val = 0;
	my $maxatoms = 200;
	
	foreach my $atom (atoms($mol)) {
	
		++$i;
		
		if ($atom->{ELEMENT} eq 'H') {
		
			if (!defined $atom->{CONNECT}[0]) {
				$mol->{HAS_HYDROGENS} = -1;
				return -1;
			}
			
			my $con = $mol->{ATOMS}[$atom->{CONNECT}[0]];
			
			++$h_con_c if $con->{ELEMENT} eq 'C';
			++$h_con_p if $con->{ELEMENT} eq 'N' || $con->{ELEMENT} eq 'O';
		}
		
		++$c if $atom->{ELEMENT} eq 'C';
		
		if ($i > 10 && $c && $h_con_c > $c/2) {
			#print "Has all hydrogens $h_con_c $c $i\n";
			$mol->{HAS_HYDROGENS} = 2;
			return 2;
		}
		
		#print "a i $i conc $h_con_c c $c conp $h_con_p\n";
				
		last if !$read_all && $i == $maxatoms;
	}
	
	# In case we had less than 10 atoms
	if ($c && $h_con_c > $c/2) {
		#print "Has all hydrogens $h_con_c $c\n";
		$mol->{HAS_HYDROGENS} = 2;
		return 2;
	}
	
	if ($h_con_p) {
		#print "b i $i conc $h_con_c c $c conp $h_con_p\n";
		$mol->{HAS_HYDROGENS} = 1;
		return 1;
	}
	
	#print "c i $i conc $h_con_c c $c conp $h_con_p\n";
	#print "Has no hydrogens\n";
	$mol->{HAS_HYDROGENS} = 0;
	return 0;
}



sub molecule_delete_h {
	
	#<
	#? Delete all hydrogens from a molecule
	#; Requires: Molecule
	#; Returns: number of deleted hydrogens
	#>

	my $mol = $_[0];
	
	my $delcount = 0;
	my $i = 0;
	foreach my $atom (atoms($mol)) {

		# Delete hydrogens
		if  ($atom->{ELEMENT} eq 'H') {
		
			molecule_delete_atom($mol, $i);
			++$delcount;
		}
		
		++$i;
	}
	
	# Pack and renumber remaining atoms
	molecule_pack($mol);
	$mol->{NUMBONDS} = molecule_count_numbonds($mol);

	return $delcount;
}

sub molecule_delete_nonpolar_h {
	
	#<
	#? Delete nonpolar hydrogens from a molecule
	#. Flag will to retain hydrogens bonded to SP2 carbons (aldehydes, aromatic rings, double bonds, etc)
	#. Charges on the hydrogens being deleted are transferred on to the parent atom.
	#; Requires: molecule, flag
	#; Returns: number of deleted hydrogens
	#>

	my $mol = $_[0];
	my $flag = $_[1];
	
	my $b;
	my $con;
	my $con2;
	my $charge;
	my $delcount = 0;
	
	my $i = -1;
	ATOM: foreach my $atom (atoms($mol))  {
		++$i;

		# If atom is a hydrogen
		next if $atom->{ELEMENT} ne 'H';

		# Loop over atoms connected to hydrogen.
		# There should be only one but there can be more if geometries are poor.
		foreach $con (@{$atom->{CONNECT}}) {

			my $conatom = $mol->{ATOMS}[$con];

			if ($conatom->{SUBID} != $atom->{SUBID}) {
				
				my $string = "Skipping hydrogen $conatom->{NUM}";
				$string .= " (name \"$conatom->{NAME}\",";
				$string .= " residue \"$conatom->{SUBNAME} $conatom->{SUBID}\")";
				$string .= " connected to atom $atom->{NUM}";
				$string .= " (name \"$atom->{NAME}\",";
				$string .= " residue \"$atom->{SUBNAME} $atom->{SUBID}\")";
				
				silico_msg('w', "$string\n");
				next;
			}
			
			next if ($conatom->{ELEMENT} ne'C');
			
			foreach $b (@{$conatom->{BORDERS}}) {
				
				next ATOM if $b == 2 || $b == 4;;
			}
			
			$charge = $atom->{CHARGE} || 0; # Charge on hydrogen
			molecule_delete_atom($mol, $i);
			$conatom->{CHARGE} += $charge; # Add charge to parent atom
			++$delcount;
		}
	}
		
	# Pack and renumber remaining atoms
	molecule_pack($mol);
	#$mol->{NUMBONDS} = molecule_count_numbonds($mol);

	return $delcount;
}

sub molecule_delete_polar_h {
	
	#<
	#? Delete polar hydrogens (ie those not attached to carbon) from a molecule
	#; Requires: molecule
	#; Returns: number of deleted hydrogens
	#>

	my $mol = $_[0];
	my $i;
	my $con;
	my $conatom;
	my $atom;
	my $delcount = 0;
	
	$i = -1;
	foreach $atom (atoms($mol))  {
		++$i;

		next if $atom->{ELEMENT} ne 'H';

		# Loop over atoms connected to hydrogen
		# There _should_ only be one but
		# There can be more if geometries are poor
		foreach $con (@{$atom->{CONNECT}}) {

			$conatom = $mol->{ATOMS}[$con];

			if ($conatom->{SUBID} != $atom->{SUBID}) {
				
				my $string = "Skipping hydrogen $conatom->{NUM}";
				$string .= " (name \"$conatom->{NAME}\",";
				$string .= " residue \"$conatom->{SUBNAME} $conatom->{SUBID}\")";
				$string .= " connected to atom $atom->{NUM}";
				$string .= " (name \"$atom->{NAME}\",";
				$string .= " residue \"$atom->{SUBNAME} $atom->{SUBID}\")";
				
				silico_msg('w', "$string\n");
				next;
			}

			# Delete it if it is not connected to a carbon
			if ($conatom->{ELEMENT} ne 'C') {
				molecule_delete_atom($mol, $i);
				++$delcount;
			}
		}
	}
		
	# Pack and renumber remaining atoms
	molecule_pack($mol);

	return $delcount;
}

sub sanitise_hydrogens {

	#<
	#? Make sure that every hydrogen has the same residue name, number, segid
	#  and chain as the parent atom
	#; Requires: molecule
	#>

	my $mol = $_[0];
	
	my $atom;
	my $parent;
	
	foreach $atom (atoms($mol)) {
	
		next if $atom->{ELEMENT} ne 'H';

		# Hydrogen has more than one connected atom.
		# Ignore it!
		next if $#{$atom->{CONNECT}} >= 1;
		
		my @f = connected($atom, $mol);
		$parent = $f[0];
	
		$atom->{SUBNAME} = $parent->{SUBNAME};
		$atom->{SEGID} = $parent->{SEGID};
		$atom->{SUBID} = $parent->{SUBID};
		$atom->{CHAIN} = $parent->{CHAIN};
	}

}

sub calc_physiological_protonation {

	#<
	#? Use a simple algorithm to determine which functional groups will
	#  be ionised at physiological pH.
	#; Atoms are marked with a {FORMAL_CHARGE} label (These should be cleared before running this routine)
	#; Requires: molecule
	#>

	my $mol = $_[0];
	
	my $flag;
	
	foreach my $atom (atoms($mol)) {
			
		delete $atom->{ACIDBASE};
		delete $atom->{PKA};
	}
	
	mol_label_functional_group($mol);

	convert_aromatic_bonds($mol);
	
	ATOM: foreach my $atom (atoms($mol)) {
	
		if ($atom->{ELEMENT} eq 'C') {
		
			#Guanidines
			if ($atom->{FG}{GUANIDINE_C} || $atom->{FG}{GUANIDINIUM_C}) {
				
				# Put formal charge on the first atom with 2 or more bonded nonhydrogens
				foreach my $con (connected($atom, $mol)) {
					
					my $ch = bonded($con, $mol);
					
					next if ($ch->{NOT_H} < 2);
					
					$atom->{PKA} = 11;
					set_acidbase($con, $mol, 1);
					next ATOM;
				}
				
				# Otherwise put charge on the first atom
				my $con = $mol->{ATOMS}[$atom->{BORDERS}[0]];

				set_acidbase($con, $mol, 1);
			}
			
			# Carboxylates and carboxylic acids
			if ($atom->{FG}{CARBOXYLATE_C} || $atom->{FG}{CARBOXYLIC_C}) {
			
				# Put formal charge on O with single bond
				foreach my $con (connected($atom, $mol)) {
				
					if ($con->{ELEMENT} eq 'O' && $con->{BORDERS}[0] == 1) {
						set_acidbase($con, $mol, -1);
						next ATOM;
					}
				}
						
				# Otherwise put charge on the first atom
				# Put formal charge on O with single bond
				foreach my $con (connected($atom, $mol)) {
				
					if ($con->{ELEMENT} eq 'O') {
						set_acidbase($con, $mol, -1);
						next ATOM;
					}
				}
			}
		}
		
		if ($atom->{ELEMENT} eq 'N') {
		
			# Guanidines are calculated above
			next if $atom->{FG}{GUANADINE_N};
			next if $atom->{FG}{GUANADINIUM_N};
			
			# Other nonprotonated nitrogens
			next if  $atom->{FG}{SULFONAMIDE_N};
			
			# Nitrogens in 5-membered heterocycles
			if (defined $atom->{PRINGS}[0]) {
			
				# Count number of nonhydrogen bonds to atom
				# Skip if we have 3 nonhydrogen bonds
				my $hetbo = 0;
				my $i = -1;
				foreach my $con (connected($atom, $mol)) {
						
					++$i;
					next if ($con->{ELEMENT} eq 'H');
					$hetbo += $atom->{BORDERS}[$i];
				}
				
				next ATOM if $hetbo >= 3;
			
				# Put negative charge on tetrazoles and triazoles
				# skip other heterocycles
				foreach my $ring (@{$atom->{PRINGS}}) {
				
					# only 5-membered rings
					next if $#{$ring} != 4;
					
					my $hetname = identify_heterocycle($ring, $mol);

					#silico_msg('g', "Heterocycle name: $hetname\n");
					
					if ($hetname =~ /TRIAZOLE/ || $hetname =~ /TETRAZOLE/) {
					
						set_acidbase($atom, $mol, -1);
						next ATOM;
					} else {
						next ATOM;
					}
				}
			}
				
			# Nitro groups
			if ($atom->{FG}{NITRO_N}) {
				
				$atom->{FORMAL_CHARGE} = 1;
			
				$flag = 1;
				foreach my $con (connected($atom, $mol)) {
				
					next if $con->{ELEMENT} ne 'O';
					if ($flag) {
						$con->{FORMAL_CHARGE} = -1;
						bond_modify_order($mol, $atom, $con, 1);
						$flag = 0;
					} else {
						delete $atom->{FORMAL_CHARGE};
						bond_modify_order($mol, $atom, $con, 2);
					}
				}
				
				next;
			}
			
			# Skip nitriles
			foreach my $bo (@{$atom->{BORDERS}}) {
				
				next ATOM if $bo == 3;
			}
			
			foreach my $con (connected($atom, $mol)) {
			
				# Skip if we are next to a planar carbon
				# eg double bond or planar ring
				next ATOM if ($con->{ELEMENT} eq 'C' && $con->{PLANAR_ATOM});
				
				# Skip if we are connected to oxygen
				next ATOM if ($con->{ELEMENT} eq 'O');
				
				# Skip if we are connected to sulfur
				next ATOM if ($con->{ELEMENT} eq 'S');
			}
			
			# Generic aliphatic amine (primary, secondary or tertiary)
			$atom->{PKA} = 10;
			set_acidbase($atom, $mol, 1);
		}
	}
	
	foreach my $atom (atoms($mol)) {
	
		$mol->{FORMAL_CHARGE}+= $atom->{FORMAL_CHARGE} || 0;
	}
	
	$mol->{HAS_FORMAL_CHARGES} = 1;
	$mol->{SDF_DATA}{FORMAL_CHARGE} = $mol->{FORMAL_CHARGE};
	
	if ($Silico::debug) {
		make_atomset($mol, 'FORMAL_CHARGE', 'FORMAL_CHARGE');
		make_atomset($mol, 'ACIDBASE', 'ACIDBASE');
	}
}

sub set_acidbase {

	#<
	#? Set formal charges on acidic/basic atoms
	#. Uses the subroutine find_nearby_formal_charges to prevent setting charges near to atoms that are already charged
	#. Currently set to search five bonds away
	#; Requires: atom, molecule, formal charge
	#; Returns: 1 if charge set, 0 if not set
	#>

	my $atom = $_[0];
	my $mol = $_[1];
	my $charge = $_[2];

	my $catom;
	my @charge_list;

	if ($atom->{FORMAL_CHARGE}) {
		silico_msg('n', "Skipping charge addition of $charge to atom $atom->{NUM} (name \"$atom->{NAME}\") because it already has a formal charge ($atom->{FORMAL_CHARGE}).\n");
		return 0;
	}

	@charge_list = find_nearby_charges_recursive($mol, 5, $atom);
	
	#silico_msg('g', heading("Charge list"));
	#foreach $catom (@charge_list) {
		#silico_msg('g', "\nAtom $catom->{NUM} (name \"$catom->{NAME}\", element \"$catom->{ELEMENT}\")\n");
	#}
	#silico_msg('g', "\n");
	
	foreach $catom (@charge_list) {

		#silico_msg('g', "Skipping charge addition of $charge to atom $catom->{NUM} (name \"$catom->{NAME}\") because of a close charge ($charge) on atom $atom->{NUM} (name \"$atom->{NAME}\").\n");
		return 0 if ($catom->{FORMAL_CHARGE} * $charge > 0);
	}

	$atom->{FORMAL_CHARGE} = $charge;
	$atom->{ACIDBASE} = $charge;

	return 1;
}

sub find_nearby_charges_recursive {

	#<
	#? Recursive subroutine to find atoms with formal charges
	#>

	my $mol = shift;
	my $level = shift;

	my $atom;
	my $con;
	my @list;
	my @path;
	@path = @_;
	my $x;
	
	--$level;
	
	$atom = $path[-1];
	$x = $atom->{ACIDBASE} || '';

	if ($level >  0) {

		foreach $con (connected($atom, $mol)) {

			# Skip parent
			next if defined ($path[-2]) && $con == $path[-2];

			@list = (@list, find_nearby_charges_recursive($mol, $level, @path, $con));
		}
	}

	if ($atom->{ACIDBASE}) {
		push @list, $atom;
	}

	return @list;
}

sub convert_aromatic_bonds {

	#<
	#? Convert non-ring aromatic bonds to double/single
	#. Note that this conversion is 'undone' by the write_mol2 subroutine
	#; Requires: molecule
	#>

	my $mol = $_[0];

	my @list;
	my %std_valence;
	my %max_valence;

	%std_valence = qw(C 4 N 3 O 2 S 2 P 2);
	%max_valence = qw(C 4 N 4 O 3 S 2 P 2);

	# Find rings if required
	molecule_find_rings($mol) if !$mol->{RINGSIZE_MAX} || $mol->{RINGSIZE_MAX} < 6;
	
	# Convert all aromatic bonds to single bonds
	# Save converted bonds in a list
	foreach my $atom (atoms($mol)) {
		
		# Convert all aromatic bonds to single
		my $i = -1;
		foreach my $con (connected($atom, $mol)) {
		
			++$i;
			my $bo = $atom->{BORDERS}[$i];
			next if $bo != 4;

			# Skip if both atoms are in a ring
			next unless ($con->{NOTRING} || $atom->{NOTRING});
			
			bond_modify_order($mol, $atom, $con, 1);

			# Save atoms with aromatic bonds
			push @list, $atom;
			push @list, $con;
		}
	}

	# Now modify bonds to fill valences with double bonds
	while (1) {
		
		my $a1 = shift @list;
		my $a2 = shift @list;

		last if !defined $a1;

		next if !defined $max_valence{$a1->{ELEMENT}} || !defined $max_valence{$a2->{ELEMENT}};

		if (valence($a1) < $std_valence{$a1->{ELEMENT}} && valence($a2) < $max_valence{$a2->{ELEMENT}}) {
			bond_modify_order($mol, $a1, $a2, 2);
			next;
		}
		if (valence($a1) < $max_valence{$a1->{ELEMENT}} && valence($a2) < $std_valence{$a2->{ELEMENT}}) {
			bond_modify_order($mol, $a1, $a2, 2);
			next;
		}
	}

	foreach my $atom (atoms($mol)) {

		next unless $atom->{NOTRING};
		foreach my $bo (@{$atom->{BORDERS}}) {

			next if $bo != 4;

			silico_msg('w', "Atom $atom->{NUM} (name \"$atom->{NAME}\") still contains aromatic bonds!\n",
					"Bond orders: ".join(", ", @{$atom->{BORDERS}})."\n");
		}
	}
}

sub make_vectors_connected {

	#<
	#? Make two unit vectors which are normal to and in the plane of
	#  atom -> con1 -> con2
	#>

	my $atom = $_[0];
	my $mol = $_[1];

	my $con1;
	my $con2;
	my ($cx, $cy, $cz);
	my ($px, $py, $pz);
	my $dummyatom;

	# No connected atoms
	if ($#{$atom->{CONNECT}} == -1) {
		return (1,0,0,0,1,0);
	}

	$con1 = $mol->{ATOMS}[$atom->{CONNECT}[0]];

	if ($#{$con1->{CONNECT}} >= 1) {

		# connected atom has two or more atoms bonded to it
		$con2 = $mol->{ATOMS}[$con1->{CONNECT}[0]];
		($cx, $cy, $cz) = atom_cross_prod ($atom, $con1, $con2) if $con2 != $atom;

		$con2 = $mol->{ATOMS}[$con1->{CONNECT}[1]];
		($cx, $cy, $cz) = atom_cross_prod ($atom, $con1, $con2) if $con2 != $atom;

	} else {

		# Conected atom has one bonded atom (atom)
		$dummyatom->{X} = $atom->{X} + 1;
		$dummyatom->{Y} = $atom->{Y};
		$dummyatom->{Z} = $atom->{Z};

		($cx, $cy, $cz) = atom_cross_prod ($atom, $con1, $dummyatom);
	}

	$dummyatom->{X} = $atom->{X} + $cx;
	$dummyatom->{Y} = $atom->{Y} + $cy;
	$dummyatom->{Z} = $atom->{Z} + $cz;

	($px, $py, $pz) = atom_cross_prod ($atom, $con1, $dummyatom);

	return $px, $py, $pz, $cx, $cy, $cz;
}

sub findclash {

	#<
	#? Find the distance to the closest atom from a point x, y, z
	#; Requires: molecule, x, y, z
	#; Returns: distance
	#>

	my $mol = $_[0];
	my $parent = $_[1];
	my $x = $_[2];
	my $y = $_[3];
	my $z = $_[4];
	
	my $smallest_sq = 9999;
	
	foreach my $atom (atoms($mol)) {
		
		next if $atom == $parent;
	
		my $a = $atom->{X} - $x;
		next if $a > $smallest_sq;
		my $b = $atom->{Y} - $y;
		next if $b > $smallest_sq;
		my $c = $atom->{Z} - $z;
		next if $c > $smallest_sq;
		
		my $dist_sq = $a**2 + $b**2 + $c**2;
		
		$smallest_sq = $dist_sq if $dist_sq < $smallest_sq;
	}

	return sqrt ($smallest_sq);
}

return 1;
