#!/usr/bin/perl -w

#  COPYRIGHT NOTICE
#  
#  Silico - A Perl Molecular Toolkit
#  Copyright (C) 2008-25 David K. Chalmers and Benjamin P. Roberts,
#  Department of Medicinal Chemistry, Monash University
#  
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.


#<
#! mol_filter
#? Filter a set of molecules by SDF property and/or molecular weight.
# 
#. The 'noparse' option can greatly speed up proscessing of SDF and some other formats 
#  by avoiding processing of most atom and bond information.  This is not 
#  compatible with the -fg option.
#. Can be used to retain molecules with a unique SDF_CODE
#F
#; -p_<name> SDF property name
#; -max_<val> Property maximum value
#; -min_<val> Property minimum value
#; -mwmax_<val> MW maximum value
#; -mwmin_<val> MW minimum value
#; -hamax_<val> Heavy atom maximum value
#; -hamin_<val> Heavy atom minimum value
#; -druglike Select druglike compounds (max MW 500, min MW 150)
#; -leadlike Select leadlike compounds (max MW 400, min MW 75)
#; -fragmentlike Select fragmentlike compounds (MW 300, min MW 60)
#; -u Retain only a single molecule foreach unique value of this SDF field. e.g. 
#     retain only a single molecule for each molecule NAME
#; -fg_<list_of_groups,_space_delimited> Retain only compounds containing these functional groups.  
#   Functional group names are determined by mol_label_functional_groups 
#; -c <string> Select compounds containing <string> in the id field (case insensitive). The id field is set using the -id flag
#; -cw The -c flag must only match a whole word
#; -list_<filename> Select compounds matching a list provided in a file. File must contain one string to be matched per line
#; -id_<id> SDF field for list filter
#; -v Verbose. Print information about discarded compounds
#; -np	Use noparse option (much faster, but currently only available for sdf files)
#SF
#. Created: DKC 2003
#. $Revision: 1.32.2.3.2.5 $
#>

use strict;
package Silico;

#########################
# Variable declarations #
#########################

my $arg;
my @arguments;
my $hash;
my $options;

my $starttime = (times)[0];
my $total_retain = 0;
my $total_discard = 0;

###################
# Start of script #
###################

silico_setup();
print_title("mol_filter", '$Revision: 1.32.2.3.2.5 $');

my $prop =  	make_flag('p', undef,  'Property name', 1);
my $prop_max = 	make_flag('max', undef,  'Property maximum', 1,  undef);
my $prop_min = 	make_flag('min', undef,  'Property minimum', 1,  undef);
my $mw_min = 	make_flag('mwmin', undef,  'MW minimum', 1,  undef);
my $mw_max = 	make_flag('mwmax', undef,  'MW maximum', 1,  undef);
my $ha_min = 	make_flag('hamin', undef,  'Minimum heavy atoms', 1,  undef);
my $ha_max = 	make_flag('hamax', undef,  'Maximum heavy atoms', 1,  undef);
my $druglike = 	make_flag('druglike', undef,  'Select druglike compounds');
my $leadlike = 	make_flag('leadlike', undef,  'Select leadlike compounds');
my $fragmentlike = make_flag('fragmentlike', undef,  'Select fragmentlike compounds');
my $unique_id = make_flag('u', 'unique-id',  'Retain only a single molecule foreach unique value of this SDF field', 1);
my $fgs = 	make_flag('fg', 'functional-group',  'Retain only compounds containing this (these) functional group(s)', 2);
my $cfn = 	make_flag('cf', 'carbanion-filter',  'Filter carbanions');
my $verbose =   make_flag('v', 'verbose',  'Print information about discarded compounds');
my $np = 	make_flag('np', 'noparse', "Use noparse option");
my $listfile = 	make_flag('list', 'list-file', "Select compounds matching a list provided in a file. One ID per line", 1);
my $contains = 	make_flag('c', 'contains', "Keep structures containing this string in the 'id' field", 1);
my $contains_ww = make_flag('cw', 'contains-whole-word', "Only match whole word using -c flag");
my $id  = 	make_flag('id', 'id', "Identifier field for 'list' or 'contains' filter", 1);

my $count;
my $name;
my $noatomcount;

if ($np || $cfn) {

	if ($fgs) {
		silico_msg('w', "Option 'noparse' is not compatible with 'fg' or 'cf' options\n");
	} else {
		$options .= 'NOPARSE ';
	}
}

@arguments = get_arguments2('>=1');
my $ostring = 'filter';

if ($druglike) {

	print "Selecting leadlike compounds\n";
	$mw_max = 500;
	$mw_min = 150;
	$ostring = 'druglike';

} elsif ($leadlike) {

	print "Selecting leadlike compounds\n";
	$mw_max = 400;
	$mw_min = 75;
	$ostring = 'leadlike';

} elsif ($fragmentlike) {

	$mw_max = 3000;
	$mw_min = 60;
	$ostring = 'fragmentlike';
}

if ($contains || $contains_ww) {

	silico_msg('d', "ID field not defined for list filter\n") if !$id;

}



my $listhash;
if ($listfile) {

	silico_msg('d', "ID field not defined for list filter\n") if !$id;

	open (INFILE, $listfile) || silico_msg('d', "Could not open file $listfile\n");
 
	while (<INFILE>) {

		chomp;
		next if !$_;
		++$listhash->{$_};
	}

	$count = keys %$listhash;

	print "Read $count values from file $listfile\n";
}

print "\n";
print "MW max: $mw_max\n" if $mw_max;
print "MW min: $mw_min\n" if defined $mw_min;
print "HA max: $ha_max\n" if $ha_max;
print "HA min: $ha_min\n" if defined $ha_min;

foreach $arg (@arguments) {
	
	$count = 0;
	my $count2 = 0;
	my $mol;
	my $mols;
	my $newmols = ();
	$noatomcount = 0;
	my $discard = 0;
	my $retain = 0;
	my $fr_in;
	my $fr_keep;
	#my $fr_discard;
	
	silico_msg('c', "File: $arg\n");
	
	while ($mol = read_mol_single($fr_in, $arg, $options)) {

		my $p;
		
		$count2 = 0 if $count <= 100 && $count2%10 == 0;
		$count2 = 0 if $count <= 1000 && $count2%100 == 0;
		$count2 = $count2-1000 if  $count2 >= 1000;
		
		if ($count2 == 0  && $count > 1) {
			silico_msg('c', "Read $count molecules.\tDiscarded $discard\n");
		}
		
		++$count;
		++$count2;

		$name = $mol->{NAME} || $count;

		my $val = 	has_atoms($mol) &&
				has_unique_id($mol) && 
				has_prop($mol) && 
				has_good_mw($mol) &&
				has_good_ha($mol) &&
				matches_list($mol) &&
				matches_fg($mol) &&
				contains($mol) &&
				!carbanion_filter_neutraliser($mol);

		if (!$val) {
			++$discard;
			#write_mol_single($fr_discard, $mol);
			next;
		}
			
		++$retain;
		
		write_mol_single($fr_keep, $mol);
        
	}

	close_molfile($fr_in);
	close_molfile($fr_keep);
	#close_molfile($fr_discard);
	
	silico_msg('c', "\n");
	silico_msg('c', "Skipped $noatomcount molecules containing no atoms.\n") if $noatomcount;
	silico_msg('c', "Retained $retain molecules and discarded $discard molecules from this file\n");
	
	$total_retain += $retain;
	$total_discard += $discard;
}

print "Retained $total_retain molecules and discarded $total_discard molecules from all files\n" if $#arguments > 0;

print_finished_message();
print_timing_message($starttime);

#################
# End of script #
#################






###############
# Subroutines #
###############

sub contains {

	my $mol = $_[0];
	
	return 1 if !$contains;
	
	return 0 if !defined $mol->{SDF_DATA}{$id}; 
	
	if (($contains_ww && $mol->{SDF_DATA}{$id} =~ /\b$contains\b/i) || (!$contains_ww && $mol->{SDF_DATA}{$id} =~ /$contains/i)) {
	
		print "Molecule $mol->{NAME}. " if $mol->{NAME};
		print "Field $id contains $mol->{SDF_DATA}{$id}\n";
		return 1;
	}
	
	return 0;
}

sub matches_fg {

	my $mol = $_[0];

 	return 1 if !defined $fgs->[0];

	mol_label_functional_group($mol);
	
	my $g;
	my $n;
	my $fg;
	my $flag = 0;
	LOOP: foreach $fg (@{$mol->{FG}}) {
	
		$n = $fg->{NAME};
		#print "n $n\n";
		if (!defined $n) {
			my $ens;
			$ens->[0] = $mol;
			write_mol2($ens, "error_$count");
			next;
		}

		foreach $g (@$fgs) {
		
			next if $n ne $g;
			$flag = 1;
			#print "match $n $g\n";
			last LOOP;
		}
	}

	return $flag;
}

sub matches_list {

	my $mol = $_[0];

	return 1 if !$listfile;

	if (!defined $mol->{SDF_DATA}{$id} || !$listhash->{$mol->{SDF_DATA}{$id}}) {

		$verbose && print "Discarded molecule with $id = '".($mol->{SDF_DATA}{$id}|| "UNDEFINED")."'. Name '$mol->{NAME}'\n";
	
		return 0;
	}

	$verbose && print "Retained molecule with  $id = '$mol->{SDF_DATA}{$id}'. Name '$mol->{NAME}'\n";

	return 1;
}

sub has_good_ha {

	my $mol = $_[0];

	return 1 if !(defined $ha_max || defined $ha_min);

	my $ha = $mol->{NUMHEAVY} || mol_count_heavy_atoms($mol);

	return 0 if !defined $ha;

	$mol->{SDF_DATA}{NUMHEAVY} = $ha;
	
	if ($ha_min && $ha < $ha_min) {
		$verbose && silico_msg('c', "$count\tMolecule \"$name\" is too light. HA: $ha < $ha_min. Discarding.\n");
		return 0;
	}
	if ($ha_max && $ha > $ha_max) {
		$verbose && silico_msg('c', "$count\tMolecule \"$name\" is too fat. HA: $ha > $ha_max. Discarding.\n");
		return 0;
	}
	
	return 1;
}

sub has_good_mw {

	my $mol = $_[0];

	return 1 if  !(defined $mw_max || defined $mw_min);
	
	$mol->{SDF_DATA}{MW} = $mol->{MW} = sprintf "%8.3f", molecule_mw($mol, undef, undef, 1);
	
	silico_msg('d', "Molecular weight not defined for molecule \"$name\"!\n") if !defined $mol->{MW};
	if ($mw_min && $mol->{MW} < $mw_min) {
		$verbose && silico_msg('c', "$count\tMolecule \"$name\" is too light. MW: $mol->{MW} < $mw_min. Discarding.\n");
		return 0;
	}
	if ($mw_max && $mol->{MW} > $mw_max) {
		$verbose && silico_msg('c', "$count\tMolecule \"$name\" is too heavy. MW: $mol->{MW} > $mw_max. Discarding.\n");
		return 0;
	}
	return 1;
}

sub has_prop {

	my $mol = $_[0];

	return 1 if !defined $prop;
			
	my $p = $mol->{SDF_DATA}{$prop};
			
	if (!defined $p) {
		silico_msg('w', "Property \"$prop\" not defined for molecule \"$name\"! Discarding.\n") if !defined $p;
		return 0;
	}

	if (($prop_max && $p > $prop_max) || ($prop_min && $p < $prop_min)) {
		$verbose && silico_msg('c', "Discarding molecule \"$name\" (property: \"$prop\"; value: \"$p\"\n");
		return 0;
	}

	return 1;
}

sub has_unique_id {

	my $mol = $_[0];

	return 1 if !defined $unique_id;

	if (defined $mol->{SDF_DATA}{$unique_id}) {
	
		++$hash->{$mol->{SDF_DATA}{$unique_id}};
	
		if ($hash->{$mol->{SDF_DATA}{$unique_id}} == 1) {
		
			$verbose && silico_msg('c', "Retaining \"$name\"\n");
			return 1;
			
		} else {
			$verbose && silico_msg('c', "Discarding molecule \"$name\" which has been found $hash->{$mol->{SDF_DATA}{$unique_id}} times\n");
			return 0;
		}
	} 

	$verbose && silico_msg('c', "Discarding molecule \"$name\".  Field $unique_id is not defined\n");

	return 0;
}

sub has_atoms {

	my $mol = $_[0];

	if ($mol->{NUMATOMS} == 0 && !$np) {
		$verbose && silico_msg('c', "Molecule \"$name\" contains no atoms. Discarding.\n");
		++$noatomcount;
		return 0;
	}
	
	return 1;
}

sub silico_setup {

        #<
        #? Locate the Silico libraries and read in the parent library, silico.pm
        #; Sets: $Silico::home_dir, $Silico::lib_dir
        #; Requires: nothing
        #; Returns: nothing
        #>

        die "Error: The environment variable SILICO_HOME is not set\n" if !$ENV{SILICO_HOME};

        $Silico::home_dir = $ENV{SILICO_HOME}."/";
        $Silico::lib_dir = $Silico::home_dir."lib/";
        push @INC, substr($Silico::lib_dir, 0, -1);

        require silico;
}
