#!/usr/bin/perl -w

#  COPYRIGHT NOTICE
#  
#  Silico - A Perl Molecular Toolkit
#  Copyright (C) 2008-25 David K. Chalmers and Benjamin P. Roberts,
#  Department of Medicinal Chemistry, Monash University
#  
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.


#<
#! bilayer_builder
#? Build an approximate lipid bilayer using periodic boundary conditions.
#  Molecules can be emedded in the bilayer.
#
#. For MD packages that require anisotropic simulations to have the bilayer in the XY plane, use the -xy flag.
#. By default, the bilayer is built in the XZ plane, using instances of a supplied lipid file.
#. Lipid molecules are reoriented along their polar axis, unless the -no flag is specified
#
#. Bilayers can be built with multiple constituent species. To do this, use multiple passes. 
#  That is, instances of one species are built into a bilayer, and this bilayer
#  is then "embedded" into a bilayer of the second species, and so on.
#
#. The distance between the two halves of the bilayer is controlled by the -s flag.  This
#  should be set to approximately the length of the lipid in the Y dimension.
#. Usage: bilayer_builder <lipid_file> -x <cellx> -y <celly> -z <cellz> -n1 <number of lipids layer1> 
#  [ -n2 <number of lipids layer2> -e <molecule to embed> ]
#F
#; -e_<filename> 	Embed molecule filename
#; -n1_<number> 	Number of instances of lipid to use to create monolayer 1 (top)
#; -n2_<number>		Number of instances of lipid to use to create monolayer 2 (bottom)
#; -x_<number> |
#; -y_<number> |	Dimensions of the cell in each direction
#; -z_<number> |
#; -xy                  Build bilayer in the xy plane
#; -no                  Do not reorient the polar axis of embedded lipid moleculesq
#; -trans		Translate the embedded molecule to the cell centre
#; -rand_<number>	Number of lipid bonds to randomise
#; -es_<number>		Additional distance addedd between the mid-points of the bilayers
#; -si_<factor> Initial scale factor for atom-atom packing distance (default 0.8)
#; -sm_<factor> Minimum scale factor for atom-atom packing distance (default 0.4)
#; -incr_<number> Number of unsuccesful moleucle packing trials before reducing the scale factor.  Default 100
#; -ignh_<0 or 1> Ignore hydrogen atoms (default 1)

#SF
#. Created: DKC 2001 and later
#. $Revision: 1.27.2.1.2.19 $
#>

use strict;
package Silico;

#########################
# Variable declarations #
#########################


my ($obase, $oformat);
my $starttime = (times)[0];

###################
# Start of script #
###################

silico_setup();
print_title("bilayer_builder", '$Revision: 1.27.2.1.2.19 $');
require silico_rbox;

# Command-line flags
my $embedname =  make_flag('e', 'embed-name', "Molecule to be embedded in box", 1);
my $numlipids1 = make_flag('n1', 'numlipids1', 'number of copies of lipid files in layer 1', 1, undef, undef, 'INT');
my $numlipids2 = make_flag('n2', 'numlipids2', 'number of copies of lipid files in layer 2', 1, undef, undef, 'INT');
my $cellx =      make_flag('x',  undef, 'box x', 1, undef, undef, "DECIMAL > 0");
my $celly =      make_flag('y',  undef, 'box y', 1, undef, undef, "DECIMAL > 0");
my $cellz =      make_flag('z',  undef, 'box z', 1, undef, undef, "DECIMAL > 0");
my $xy =         make_flag('xy', 'xy-plane', 'Build blayer in the xy plane', 0);
my $noorient =   make_flag('no', 'no-orent', 'Do not reorient polar axis of embedded lipid molecules before packing');
my $trans =      make_flag('trans', 'translate-embeded', "Translate the embedded molecule to the centre of cell");
my $random =     make_flag('rand', 'randomise-dihedrals', "Randomise lipid dihedrals by this number of steps", 1, 0);
my $extrasep =   make_flag('es', 'extra-sep', 'Add extra distance between bilayer centres', 1, 0);
               
	       	make_flag('si', 'init-scale-factor', "Initial scale factor for atom-atom distance", 1, 0.8, undef, 'DECIMAL >0');
               	make_flag('sm',  'min-scale-factor', "Minimum scale factor for atom-atom distance", 1, 0.4, undef, 'DECIMAL >0');
               	make_flag('incr', 'max-try-increment', "Reduce scale factor after this number of unsuccesful trials", 1, 100);
		make_flag('ignh', 'ignore-hydrogens', 'Ignore hydrogens when packing', 1, 1);

# Command-line arguments
my @arguments = get_arguments2('>=1');
my $arg = $arguments[0];

# Default filename append string
set_default_oappend('bilayer');

if (defined $numlipids1 && !defined $numlipids2) {
	$numlipids2 = $numlipids2;
	silico_msg('c', "Setting number of lipids in layer 2 to $numlipids1\n");
}

my $embed;
my $chain = 'A';
my $segid = 'SA';
if ($embedname) {

        print (heading("Molecule to be embeded\n"));

        # Read in molecule to be embedded in bilayer
        my $e = read_mol_any ($embedname) || mol_read_error($embedname, 1);

        $embed = $e->[0];
        silico_msg('w', "Multiple molecules found in 'embed' file. Only the fist molecule will be used\n") if defined $e->[1];

        # Check and fix the connectivity in this molecule
        molecule_check_and_fix_connectivity($embed);
	
	# Set flags so that vdw radii of embedded molecule are not scaled down.
	dont_scale_vdw($embed);

        ($cellx, $celly, $cellz) = calc_box_size($embed, $cellx, $celly, $cellz, 0, 15);

        my ($maxchain, $maxsegid) = find_maxchain_maxsegid($embed);
	$chain = $maxchain;
	pdb_increment_chain($chain);
	
	$segid = $maxsegid;
	++$segid;
	
	print "Starting numbering from chain: $chain segid: $segid\n";
	
        ($obase, $oformat) = get_ofilename2($embed);
}

my $default = 10; # Default extent of box around embedded molecule
verify_input_data($cellx, "decimal > 0", "Box size (X)", $default);
verify_input_data($celly, "decimal > 0", "Box size (Y)", $default);
verify_input_data($cellz, "decimal > 0", "Box size (Z)", $default);

my $cell;
@$cell = ($cellx, $celly, $cellz);

# Read in lipid structures
my $comp;
my $maxy = 0 ;
my $maxz = 0 ;
foreach $arg (@arguments) {
	
	my $ens;
	$ens = read_mol_any($arg);
	
	# Get output filename from lipid filename if we haven't already got one
	($obase, $oformat) = get_ofilename2($ens) if !defined $obase;
	mol_read_error($arg, 1) if !defined $ens->[0];
	
	my $i = 0;
	foreach my $mol (@$ens) {

		++$i;
		push @$comp, $mol;
		
		# Check and fix the connectivity in this molecule
       		molecule_check_and_fix_connectivity($mol);
		 
		if (!$noorient) {
			print "Orienting molecule\n";
			mol_orient_polarity($mol);
		}

		my @dim = molecule_centre($mol);
		my $dx = $dim[0]-$dim[3];
		my $dy = $dim[1]-$dim[4];
		my $dz = $dim[2]-$dim[5];
		
		silico_msg('c', "\nLipid component $i.  Size: x: $dx y: $dy z: $dz\n");
		$maxy = $dy if $dy > $maxy;	
		$maxz = $dz if $dz > $maxz;	
	}
}

if ($embed && $trans) {
	print "Translating embedded molecule to centre of cell";
	molecule_trans_to_centre($embed, 'cell', 'all', $cell);
}

printbox(0, 0, 0, $cellx, $celly, $cellz);

# Generate copies of lipid(s) and put them in to ensembles layer1 and layer2

my $num_components1->[0] = $numlipids1;
my $num_components2->[0] = $numlipids2;

silico_msg ('c', heading("Making copies of molecules\n"));
$num_components1 = check_number_components($comp, $num_components1, $numlipids1);

my $layer1 = make_molecule_copies($comp, $num_components1, $chain, $segid, $random, $oformat);

$num_components2 = check_number_components($comp, $num_components2, $numlipids2);
pdb_increment_chain($chain);

my $layer2 = make_molecule_copies($comp, $num_components2, $chain, $segid, $random, $oformat);

my $molcount1 = $#{$layer1}+1;
my $molcount2 = $#{$layer2}+1;
silico_msg ('c', "\nGenerated $molcount1 lipids in layer1\n");
silico_msg ('c', "Generated $molcount2 lipids in layer2\n\n");

my $sep;
if ($xy) {
	$sep = $maxz;
} else {
	$sep = $maxy;
}

my $totalsep = $sep + $extrasep;

print "Distance between monolayer centres: $totalsep = lipid length ($sep) + extra ($extrasep)\n\n";

if (get_flag('xy-plane', 'l')) {
	print "Layer 1: ".($cellx*$celly/$molcount1)." A^2/lipid\n" if $molcount1;
	print "Layer 2: ".($cellx*$celly/$molcount2)." A^2/lipid\n" if $molcount2;
} else {
	print "Layer 1: ".($cellx*$cellz/$molcount1)." A^2/lipid\n" if $molcount1;
	print "Layer 2: ".($cellx*$cellz/$molcount2)." A^2/lipid\n" if $molcount2;
}

# Generate initial random bilayer
foreach my $mol (@$layer1) {
	
	molecule_trans_to_centre($mol, 'cell', 'all', $cell);

	if ($xy) {
		molecule_translate($mol, rand($cellx) - $cell->[0], rand($celly) - $cell->[1], $totalsep/2);
	} else {
		molecule_translate($mol, rand($cellx) - $cell->[0], $totalsep/2, rand($cellz) - $cell->[2]);
	}
	mol_move_into_cell($mol, $cell);
}

foreach my $mol (@$layer2) {
	
	molecule_rot_angle_x($mol, 180);
	molecule_trans_to_centre($mol, 'cell', 'all', $cell);
	
	if ($xy) {
		molecule_translate($mol, rand($cellx) - $cell->[0], rand($celly) - $cell->[1], -$totalsep/2);

	} else {
		molecule_translate($mol, rand($cellx) - $cell->[0], -$totalsep/2, rand($cellz) - $cell->[2]);
	}
	mol_move_into_cell($mol, $cell);
}

# Pack molecules into bilayer
my $model;
silico_msg('c', heading ("Packing $molcount1 molecules in layer 1\n"));
$model = pack_molecules($layer1, $embed, $cell);
silico_msg('c', heading ("Packing $molcount2 molecules in layer 2\n"));
$model = pack_molecules($layer2, $model, $cell);

# Set cell
$model->{CELL} = $cell;
$model->{CELL_ALPHA} = $model->{CELL_BETA} = $model->{CELL_GAMMA}= 90;

# Write output
write_mol_any($model, $obase, $oformat);

print_finished_message();
print_timing_message($starttime);

#################
# End of script #
#################






###############
# Subroutines #
###############


sub randomise_and_test_molecule_position {

	#<
	#? Perform random translation and rotation in the bilayer plane
	#  and small movements perpendicular to bilayer
	#; Requires: molecule, cell
	#; Returns: nothing
	#>

	my $mol = $_[0];
	my $cell = $_[1];
	
	my $p;
	my $offset_max = 2;
	my $pmove_max = 1;
	
	$mol->{P_OFFSET} ||= 0;
	$p = (rand(1) - 0.5) * $pmove_max * 2;
	$p = 0 if (abs($mol->{P_OFFSET}+$p) > $offset_max);
	$mol->{P_OFFSET} += $p;
	
	if (get_flag('xy-plane','l')) {
		molecule_translate($mol, rand($cell->[0]), rand($cell->[1]), $p);
		molecule_rot_angle_z($mol, rand(360));
	} else {
		# XZ plane	
		molecule_translate($mol, rand($cell->[0]), $p, rand($cell->[2]));
		molecule_rot_angle_y($mol, rand(360));
	}
}

sub silico_setup {

        #<
        #? Locate the Silico libraries and read in the parent library, silico.pm
        #; Sets: $Silico::home_dir, $Silico::lib_dir
        #; Requires: nothing
        #; Returns: nothing
        #>

        die "Error: The environment variable SILICO_HOME is not set\n" if !$ENV{SILICO_HOME};

        $Silico::home_dir = $ENV{SILICO_HOME}."/";
        $Silico::lib_dir = $Silico::home_dir."lib/";
        push @INC, substr($Silico::lib_dir, 0, -1);

        require silico;
}
