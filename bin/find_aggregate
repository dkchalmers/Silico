#!/usr/bin/perl -w
#!/usr/bin/perl -d:NYTProf -w

#  COPYRIGHT NOTICE
#
#  Silico - A Perl Molecular Toolkit
#  Copyright (C) 2008-25 David K. Chalmers and Benjamin P. Roberts,
#  Department of Medicinal Chemistry, Monash University
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

#<
#! find_aggregate
#? Identify hydrophobic aggregates of molecules (eg components of micelles)
#  in a periodic system.  Molecules are identified by connectivity and can
#  contain multiple residues. By default, two molecules are defined as belonging to the
#  same aggregate if they have carbon atoms within the distance threshold
#  This is set to 4 Ang by default
#. The definition of an aggregate can be changed using the -model option. The aggregate
#  model can be changed to exclude polar carbons (i.e. those attached to O or N). This
#  is useful for nonionic surfactants with PEG headgroups. The -model water option
#  can be used to calculate water aggregates
#. The -move option moves all atoms into the unit cell (molecules are often split
#  when they cross the unit cell boundaries). This is useful for generating
#  pictures in programs like Pymol
#. A Gromacs format index file (ie atoms are indexted starting from 1) can be written with the
#  -ndx flag
#. Summary data is written to <first_filename>_agg.out.  This file can be used with the unix
#  commands 'grep AGG', 'grep COUNT' or 'grep STATS' to extract only information about
#  individual aggregates, the aggregate summary or statistical values.
#. In pdb format output, the temperature factor and SEGID columns are set to reflect the aggregate.
#  In Pymol colour->spectrum->b-factor will show accregates
#. Aggregate core atoms can be renamed to 'CX' or 'OX' using the -rename flag
#. Use: find_aggregate <options> <filename>
#F
#; -t_<number> Maximum distance between key atoms in aggregate (default 4 Ang)
#; -move  Move all atoms into the unit cell (range 0 -> cell size)
#; -i_<ignore_list> List of molecule names to ignore.  Multiple residues can be listed, separated by spaces
#  and surrounded by brackets e.g. -i 'DAN SAM HAM'.  Molecule name should be the name of the first residue
#  in molecule.
#; -model_[carbon, nonpolar_c, water] Aggregate model. Carbon - find contacts between any carbon atoms. 
#  Nonpolar_c - find contacts betweetween carbons not bonded to N or O. Water - find water aggregates
#; -ndx Write Gromacs index file containing aggregates
#; -keep Retain isolated molecules in calculations of average aggregate size
#; -x_<number> }
#; -y_<number> } Cell dimensions
#; -z_<number> }
#; -rename Rename aggregate core atoms to 'CX' or 'OX'

#SF
#. $Revision: 1.32.2.14.2.14 $
#>

use strict;

package Silico;

#########################
# Variable declarations #
#########################

my $moltotal  = 0;
my $options   = '';


# Global vars :(
my $molcount;  
my $res_mw;      
my $res_formula;
my $rescount;
my $submols; 

my $starttime = (times)[0];
use vars qw($Avogadro);

###################
# Start of script #
###################:1

silico_setup();
print_title("find_aggregate", '$Revision: 1.32.2.14.2.14 $');

my $thresh = 	make_flag('t',    'thresh',     	 'Aggregate threshold', 1, 4);
my $move = 	make_flag('move', undef,           	 'Move all atoms into unit cell');
my $ignorelist = make_flag('i',    'ignore-res', 	 'List of residue names to ignore', 2);
my $model = 	make_flag('model','aggregate-model',  'Aggregate model [carbon, nonpolar_c, water]', 1, 'carbon');
my $keep_singles = make_flag('keep', 'keep-singles',	 'Retain isolated molecules in calculations of average aggregate size');
my $ndx	= 	make_flag('ndx',  'ndx',              'Write gromacs index file containing aggregates');
               	make_flag('y',    undef, 'box y', 1);
              	make_flag('z',    undef, 'box z', 1);
 	     	make_flag('norename', 'no-rename',  	 "Do not rename aggregate 'core' atoms to 'CX'");

my @arguments = get_arguments2('>=1');

@$ignorelist = () if !defined $ignorelist;
@$ignorelist = (@$ignorelist, "NA", "NA+");
my $ignorehash;
foreach (@$ignorelist) {
	$_ =~ s/ //g;
	++$ignorehash->{$_};
}

if (defined $ignorelist->[0]) {

	print heading("Ignoring residues");
	foreach (@$ignorelist) {
		print "\t'$_'\n";
	}
}

# Models
$model = lc($model);
if ($model ne 'carbon' && $model ne 'nonpolar_c' && $model ne 'water') {
	silico_msg('d', "Unknown model: '$model'\n");
} 

set_flag('noconect', 's', 1);

my $sumfile = (get_filebase($arguments[0])) . "_agg.out";
open(SUMMARY, ">$sumfile") || die "Could not open summary file $sumfile\n";

print heading("Finding residues");

# Find all residues in all input files
my $allres;
foreach my $arg (@arguments) {

	if ($arg =~ '_agg') {
		silico_msg('w', "File $arg looks like output from find_aggregate. Skipping\n");
		next;
	}

	my $mols = read_mol_any($arg);
	if (!defined $mols) {
		mol_read_error($arg, undef, undef, "QUIET");
		next;
	}

	foreach my $mol (@$mols) {
		foreach my $atom (atoms($mol)) {

			my $n = $atom->{SUBNAME};
			$n =~ s/ //g;
			next if $ignorehash->{$n};
			++$allres->{$n};
		}
	}
}

foreach my $arg (@arguments) {

	silico_msg('c', heading("\nFile: $arg\n"));

	my $mols = read_mol_any($arg);
	if (!defined $mols) {
		mol_read_error($arg);
		next;
	}

	undef $rescount; # Global
	$molcount = 0;
	foreach my $mol (@$mols) {

		++$molcount;
		++$moltotal;

		$molcount = sprintf "%03d", $molcount;
		my $filebase = get_filebase($arg);
		$filebase .= "_agg$molcount" if $#{$mols} > 0;

		# Check that periodic cell is properly set and get values from
		# input flags if required
		fix_cell_values($mol);

		# Save original atom order
		my $i = 0;
		foreach my $atom (atoms($mol)) {
			$atom->{ONUM} = $i;
			++$i;
		}
		
		my $largemol = 1 if $mol->{NUMATOMS} >= 10000;
		
		if (!$largemol) {
			molecule_check_and_fix_connectivity($mol);
		} else {
		
			silico_msg('c', heading("\nChecking connectivity\n"));
			if (!defined $mol->{NUMBONDS} || $mol->{HAS_BAD_BONDS}) {
			
				# Make single bonds between bonded atoms, but do not create bondorders
				# because aromatic bonds require find_rings, which is too slow
				connect_atoms_in_waters($mol);
				my $bondcount = connect_atoms_by_distance($mol, 1);
				delete $mol->{HAS_BAD_BONDS};
				
				# Stop check_and_fix_connectivity running again
				$mol->{CONNECTIVITY_CHECKED} = 1;
				
				print "Created $bondcount single bonds\n";
				silico_msg("w", "Creating bonds, but not correcting bondorders\n");
			}
		}
		
		silico_msg('c', heading("\nFinding molecules\n"));
		($submols, undef) = select_residues($mol, $ignorelist);

		silico_msg('c', sprintf("Found %d submolecules\n", $#{$submols} + 1));

		# Count residue types and find molecular masses
		my $count = 0;
		foreach my $submol (@$submols) {
		
			++$count;

			my $res = $submol->[0]{SUBNAME} || 'UNK';
			$res =~ s/ //g;
			++$rescount->{$res};

			if (!$res_mw->{$res}) {
				$res_mw->{$res} = molecule_mw($mol, $submol);
				$res_formula->{$res} = formula_string(molecule_formula($mol, undef, $submol));
			}
			
			#print "Submol: $count\n" if $count%100==0;
		}

		print(heading("Finding aggregates\n"));
		my $aglist = find_aggregates($mol, $submols, $thresh);

		print_output($mol, $aglist, $arg);

		# Write index file
		write_index_file($aglist, "$filebase.ndx") if $ndx;

		# Move all atoms back into cell
		mol_move_atoms_into_cell($mol) if $move;
		
		$options .= " NOBOND" if $largemol;

		# Write agg file
		write_mol_any($mol, "$filebase\_agg", "pdb", $options);
	}
}

close SUMMARY;

print_finished_message();
print_timing_message($starttime);

#################
# End of script #
#################

###############
# Subroutines #
###############



sub print_output {

	my $mol = $_[0];
	my $aglist = $_[1];
	my $arg = $_[2];

	print SUMMARY "#Aggregates\n";
	if ($moltotal == 1) {

		print SUMMARY "#AGG File                          Agg_num    Agg_mass  ";
		foreach (sort keys %$res_mw) {
			printf SUMMARY "%-6s ", $_;
		}
		print SUMMARY "\n";
	}

	my $agcount;    # Array of aggregate counts
	my @mw_list  = ();
	my $mw_mean  = 0;
	my @num_list = ();
	my $num_mean = 0;
	my $single   = 0;

	my $i = 0;
	foreach my $agg (@$aglist) {

		my $n = $#{ $agg->{SUBMOLS} } + 1;    # Number of molecules in aggregate

		# Skip single molecules (by default they are not an aggregate)
		if ($n == 1) {
			++$single;
			next if !$keep_singles;
		}

		++$agcount->[$n];
		$num_mean += $n;
		push @num_list, $n;

		my $agg_mass = 0;
		my $subrescount;    # Hash of counts
		foreach my $smol (@{ $agg->{SUBMOLS} }) {
			my $res = $smol->[0]{SUBNAME} || 'UNK';
			$res =~ s/ //g;
			++$subrescount->{$res};
			$agg_mass += molecule_mw($mol, $smol);
		}

		$agg->{MASS}             = $agg_mass;
		$agg->{SUBRESCOUNT_HASH} = $subrescount;
		
		$mw_mean += $agg_mass;
		push @mw_list, $agg_mass;
		
		printf SUMMARY "AGG %-30s %-8d %10.1f  ", $mol->{SOURCE_FILE_NAME}, $i + 1, $agg_mass;
		foreach (sort keys %$res_mw) {

			printf SUMMARY "%-6d  ", ($subrescount->{$_} || 0);
		}
		print SUMMARY "\n";

		++$i;
	}

	if ($i) {
		$num_mean /= $i;
		$mw_mean  /= $i;
	} else {
		$num_mean = '';
		$mw_mean  = '';
	}

	my $num_max = maximum(@num_list) || 0;
	my $mw_max  = maximum(@mw_list)  || 0;
	my ($num_median, $num_mad) = median_absolute_deviation(@num_list);
	my ($mw_median,  $mw_mad)  = median_absolute_deviation(@mw_list);

	$num_median ||= 0;
	$num_mad    ||= 0;
	$mw_median  ||= 0;
	$mw_mad     ||= 0;

	my $agg_star     = '';
	my $num_mad_star = '';
	$agg_star     = "*" if $#num_list < 4;
	$num_mad_star = "*" if $num_mad > $num_median / 3;

	my $l = 0;
	my $s = ' ';
	
	my $name = $mol->{SOURCE_FILE_NAME};
	$name = substr($name, 0, 26) . "..." if length $name > 30;
	
	foreach my $fh (*STDOUT, *SUMMARY) {

		print $fh "\n# Residue counts\n\n";
		print $fh "# Residue  Count  Formula                 MW_(Da)   Conc_(mM)  Tot_mass_(Da)\n";
		my $res;
		foreach my $res (sort keys(%$rescount)) {
			# Conc in mM
			my $conc = $rescount->{$res} / $Avogadro / ($mol->{CELL}[0] * $mol->{CELL}[1] * $mol->{CELL}[2] * 1e-27)*1000;
			printf $fh "# %-6s   %-6d %-20s %10.2f  %10.2f   %12.1f\n", $res, $rescount->{$res}, $res_formula->{$res}, $res_mw->{$res}, $conc,
			  $rescount->{$res} * $res_mw->{$res};

		}
		++$l;
		
		$s = "COUNT " if $l == 2;

		print $fh "\n# Aggregate counts\n\n";
		printf $fh "#$s% -29s %10s %10s %10s\n", 'File', 'Size', 'Num_agg', 'Num_mols';

		foreach my $i (0 .. $#{$agcount}) {
		
			next if !$agcount->[$i];
			printf $fh "$s%-30s %10d %10d %10d\n", $name,  $i, $agcount->[$i], $agcount->[$i] * $i;
		}

		print $fh "\n";
		printf $fh "# Total molecules: %d\n", $#{$submols} + 1;
		print $fh "\n";
		
		print $fh "\n";
		printf $fh "# Threshold distance (Ang):                   %8d\n", $thresh;
		printf $fh "# Aggregate model:      %30s\n","$model-$model";
		printf $fh "# Total number single molecules:              %8d\n", $single;
		printf $fh "# Total number of aggregates:                 %8d %s\n", $#num_list + 1, $agg_star;
		$num_max    && printf $fh "# Maximum aggregate number (molecules):       %8d\n",      $num_max;
		$num_mean   && printf $fh "# Average aggregate number (molecules):       %8.1f\n",    $num_mean;
		$num_median && printf $fh "# Median aggregate number (molecules):        %8.1f\n",    $num_median;
		$num_mad    && printf $fh "# Aggregate number median absolute deviation: %8.1f %s\n", $num_mad, $num_mad_star;

		$mw_max    && printf $fh "# Maximum aggregate MW (kDa):               %10.3f\n",    $mw_max / 1000;
		$mw_mean   && printf $fh "# Average aggregate MW (kDa):               %10.3f\n",    $mw_mean / 1000;
		$mw_median && printf $fh "# Median aggregate MW (kDa):                %10.3f\n",    $mw_median / 1000;
		$mw_mad    && printf $fh "# MW median absolute deviation (kDa):       %10.3f %s\n", $mw_mad / 1000, $num_mad_star;
		($agg_star || $num_mad_star) && printf $fh "\n# Note: A small number of aggregates present. The estimate of the true mean/median aggregate number is unreliable\n";
		print $fh "\n";
		if (!$keep_singles) {
			print $fh "# Note: All values are calculated by excluding single molecules\n";

		} else {
			print $fh "# Note: Single molecules have been retained in calcuations\n";
		}
		print $fh "\n";
	}

	print "\n";

	if ($moltotal == 1) {
		print SUMMARY "#STATS File                           ";
		foreach my $res (sort keys(%$allres)) {
			my $x = $res;
			$x =~ s/ //g;
			printf SUMMARY "%10s %10s %10s ", "Num_$x", "MW_$x", "Mass_$x";

		}

		print SUMMARY "  Single  Num_agg  Agg_max Agg_mean  Agg_med  Agg_MAD     MW_max    MW_mean     MW_med     MW_MAD Poor \n";
	}

	printf SUMMARY "STATS  %-30s ", $arg;
	foreach my $res (sort keys(%$allres)) {
		$rescount->{$res} ||= 0;
		$res_mw->{$res}   ||= 0;
		printf SUMMARY "%10d %10.2f %10.1f ", $rescount->{$res}, $res_mw->{$res}, $rescount->{$res} * $res_mw->{$res};

	}
	printf SUMMARY "%8d %8d %8d %8.1f %8.1f %8.1f %10.1f %10.1f %10.1f %10.1f    %1s ",
	  $single, $#num_list + 1, $num_max, ($num_mean || 0), $num_median, $num_mad, $mw_max, ($mw_mean || 0), $mw_median, $mw_mad, ($agg_star || '.');

	print SUMMARY "\n\n";
}

sub fix_cell_values {

	#<
	# Set cell values from command line only if not defined in input molecule file
	#>

	my $mol = $_[0];

	$mol->{CELL}[0]    ||= get_sflag('x');
	$mol->{CELL}[1]    ||= get_sflag('y');
	$mol->{CELL}[2]    ||= get_sflag('z');
	$mol->{CELL_ALPHA} ||= 90;
	$mol->{CELL_BETA}  ||= 90;
	$mol->{CELL_GAMMA} ||= 90;

	if (       !defined $mol->{CELL}[0]
		|| !defined $mol->{CELL}[1]
		|| !defined $mol->{CELL}[2])
	{
		silico_msg('d', "At least one cell dimension is not defined!\n");
	}
}


sub write_index_file {

	my $aglist  = $_[0];
	my $outfile = $_[1];

	my $counter;

	# Write index file
	open(INDEXFILE, ">$outfile") || file_write_error("$outfile", 1);

	silico_msg('c', "Writing Gromacs format index file\n");

	my $i = 1;
	foreach my $agg (@$aglist) {
	
		$counter = 0;
		print INDEXFILE "[ aggregate$i ]\n";

		foreach my $amol (@{$agg->{SUBMOLS}}) {

			foreach my $atom (@$amol) {
				printf INDEXFILE "%-8d ", $atom->{ONUM} + 1;

				++$counter;
				if ($counter == 10) {
					$counter = 0;
					print INDEXFILE "\n";
				}
			}
		}

		print INDEXFILE "\n" if $counter != 0;
		++$i;
	}

	close INDEXFILE;
}

sub mark_relevant_atoms {

	#<
	#? Mark 'aggregate' atoms with ACTIVE flag
	#; Requires: Molecule
	#; Returns: Nothing

	my $mol = $_[0];
	
	my $model = get_sflag('model');
	$model = lc($model);
	
	my $rename = get_sflag('rename');

	# Mark atoms that are going to be considered in aggreagate with a ACTIVE flag
	my $active_count = 0;
	
	if ($model eq 'water') {
		
		label_waters($mol);
		
		foreach my $atom (atoms($mol)) {
			
			next if !$atom->{FG}{W};
			next if $atom->{ELEMENT} ne 'O';
			$atom->{NAME}    = 'OX' if $rename;
		
			$atom->{ACTIVE} = 1;
			++$active_count;
		}
		
		
	} elsif ($model eq 'nonpolar_c') {
	
		foreach my $atom (@{ $mol->{ATOMS} }) {

			my $flag = 0;
			next if $atom->{ELEMENT} ne 'C';
		    	  LOOP: foreach my $con (connected($atom, $mol)) {

				if ($con->{ELEMENT} eq 'N' || $con->{ELEMENT} eq 'O') {
					$flag = 1;
					last LOOP;
				}
				}
			next if $flag;
			$atom->{ACTIVE} = 1;
			$atom->{NAME}    = 'CX' if $rename;
			++$active_count;
		}

	} else {
		
		foreach my $atom (@{ $mol->{ATOMS} }) {

			next if $atom->{ELEMENT} ne 'C';
			$atom->{ACTIVE} = 1;
			$atom->{NAME}    = 'CX' if $rename;
			++$active_count;
			
		}
	}

	if ($active_count) {
		print "Using $active_count atoms for clustering\n\n";
	} else {
	
		print "\n";
		silico_msg('w', "No active atoms found\n\n");
	}
	
}

sub find_aggregates {

	#<
	#? Subroutine to find aggregates using the faster 'find_close_atoms_binned' routine
	#. Clusters are defined has having carbon atoms within distance 'cutoff'
	#; Requires; molecule, submolecules, cutoff distance
	#; Returns; Array of clusters.  Each custer is a hash containing: {SUBMOLS} array of submolecules
	#>

	my $mol     = $_[0];
	my $submols = $_[1];
	my $cutoff  = $_[2] || 2;

	my $i            = 0;
	my $warn_res;

	my $aglist;
	@$aglist = ();

	silico_msg('d', "Error: The size of the cell is not defined!\n") if !defined $mol->{CELL};

	molecule_bin_atoms($mol);

	# Find relevant atoms for aggregates with a ACTIVE flag (all C atoms by default).
	mark_relevant_atoms($mol);

	my $list;
	my $clustercount = -1;
	foreach my $smol (@$submols) {

		# Skip if submol has no active atoms
		my $smol_act = submol_active_atoms($smol, $warn_res);
		next if !$smol_act;

		# Skip if submol is already allocated
		next if (defined $smol->[0]{CLUSTER});

		# Allocate submol to a cluster
		@$list = ();

		++$clustercount;
		
		# Put the submol onto list
		push @$list, $smol;
		push @{ $aglist->[$clustercount]{SUBMOLS} }, $smol;

		my $bins;
		while (my $smol1 = shift @$list) {

			my $smol1_act = submol_active_atoms($smol1, $warn_res);
			next if !$smol1_act;

			# Find neigbouring atoms
			my $close_atoms = find_close_atoms_binned($smol1_act, $mol, $cutoff);
			++$i;

			#print "$i close_atoms $#{$close_atoms}\n";

			foreach my $atom (@$close_atoms) {

				# Skip atoms that have already been allocated to a cluster
				next if defined $atom->{CLUSTER};
				next if !defined $atom->{SUBMOL};

				# Skip non-ACTIVE atoms
				next if !$atom->{ACTIVE};

				#next if $atom->{ELEMENT} ne 'C';

				my $smol2 = $submols->[ $atom->{SUBMOL} ];

				# Allocate all atoms in molecule 2 to cluster
				foreach my $atom2 (@$smol2) {
					$atom2->{CLUSTER} = $clustercount;
				}

				# Add the molecule on the list to find neigbours
				push @$list, $smol2;
				push @{ $aglist->[$clustercount]{SUBMOLS} }, $smol2;
			}
		}
	}

	foreach (keys %$warn_res) {
		silico_msg('w', "Residue $_ did not contain any 'active' atoms. Setting SEGID to 'NONE'.  Residue found $warn_res->{$_} times\n");
	}

	
	# Sort aggregate list by number of members
	@$aglist = sort { $#{ $b->{SUBMOLS} } <=> $#{ $a->{SUBMOLS} } } @$aglist;
	
	# Set atom SEGID by aggregate
	foreach my $smol1 (@$submols) {
		foreach my $atom (@$smol1) {
			if (!$atom->{CLUSTER}) {
				$atom->{SEGID} = "NONE";
			} else {
				$atom->{SEGID} = sprintf "A%03d", $smol1->[0]{CLUSTER};
			}
		}
	}
	
	# Set atom TEMP by size of aggregate so that colours of larger aggregates are more different
	# from smaller aggregates
	
	my $nsubmols = $#{$submols}+1;
	
	foreach my $atom (atoms($mol)) {
		$atom->{TEMP} = 0;
	}
	
	foreach my $ag (@$aglist) {
	
		my $nag = $#{$ag->{SUBMOLS}}+1;
		
		my $t = $nag/$nsubmols * 80;
	
		foreach my $smol (@{$ag->{SUBMOLS}}){
		
			foreach my $atom (@$smol) {
				$atom->{TEMP} = $t;
			}
		}
	}

	
	return ($aglist);
}

sub submol_set_cluster {

	#<
	#? Assign all atoms in a submol to a cluster
	#>

	my $smol = $_[0];
	my $cluster = $_[1];
	
	foreach my $atom (@$smol) {
		$atom->{CLUSTER} = $cluster;
	}
}

sub submol_active_atoms {

	#<
	#? Find active atoms in submol
	#>
	
	my $smol = $_[0];
	my $warn_res = $_[1];

	my $smol_act;
	foreach my $atom (@$smol) {
		next if !$atom->{ACTIVE};
		push @$smol_act, $atom;
	}

	if (!defined $smol_act) {

		my $res = $smol->[0]{SUBNAME};
		$res =~ s/ //g;
		++$warn_res->{$res};
	} 
	
	return $smol_act
}

sub select_residues {

	#<
	#? Select important residues
	#. Submolecules are identified by connectivity.  Waters are excluded
	#; Returns: array of residues, pseudo molecule containing all interesting atoms
	#>

	my $mol        = $_[0];
	my $ignorelist = $_[1];

	my $alist;
	my $hash;
	my $submols;

	my $slist = molecule_label_submols($mol);

	# Reset submols
	foreach my $atom (atoms($mol)) {
		delete $atom->{SUBMOL};
	}

	foreach (@$ignorelist) {
		$_ =~ s/ //;
		++$hash->{$_};
	}

	my $i = -1;
      ATOM: foreach my $atoms (@$slist) {

		my $n = $atoms->[0]{SUBNAME} || 'UNK';
		$n =~ s/ //g;

		# Skip ignored residues
		next if $hash->{$n};

		++$i;

		# Save residue
		push(@$submols, $atoms);

		# Save residue atoms
		foreach my $atom (@$atoms) {
			push @$alist, $atom;
			$atom->{SUBMOL} = $i;

			#$atom->{SEGID} = $i;
			$atom->{TEMP} = $i;
			$atom->{CHAIN} ||= 'A';
		}
	}

	# Debugging code to write pdb file
	if (0) {
		my $ens;
		$ens->[0] = $mol;
		write_pdb($ens, 'temp.pdb');
	}

	return ($submols, $alist);
}

sub silico_setup {

	#<
	#? Locate the Silico libraries and read in the parent library, silico.pm
	#; Sets: $Silico::home_dir, $Silico::lib_dir
	#; Requires: nothing
	#; Returns: nothing
	#>

	die "Error: The environment variable SILICO_HOME is not set\n" if !$ENV{SILICO_HOME};

	$Silico::home_dir = $ENV{SILICO_HOME} . "/";
	$Silico::lib_dir  = $Silico::home_dir . "lib/";
	push @INC, substr($Silico::lib_dir, 0, -1);

	require silico;
}
